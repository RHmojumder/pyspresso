import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from random import randint
import numpy.linalg as la
import numpy as np
import copy

pi = np.pi
xHat = np.array([1.0, 0.0, 0.0])
yHat = np.array([0.0, 1.0, 0.0])
zHat = np.array([0.0, 0.0, 1.0])
zeroVector = np.array([0.0,0.0,0.0])

def Ry(theta):
	"""Generates a matrix which will rotate a vector about the y-axis by theta degrees"""
	return np.array([[np.cos(theta), 0, np.sin(theta)],
					 [0, 1, 0],
					 [-1*np.sin(theta), 0, np.cos(theta)]])

def Rz(theta):
	"""Generates a matrix which will rotate a vector about the z-axis by theta degrees"""
	return np.array([[np.cos(theta), -1*np.sin(theta), 0],
				[np.sin(theta), np.cos(theta), 0],
				[0, 0, 1]])

def Rx(theta):
	"""Generates a matrix which will rotate a vector about the x-axis by theta degrees"""
	return np.array([[1, 0, 0],
					[0, np.cos(theta), -1*np.sin(theta)],
					[0, np.sin(theta), np.cos(theta)]])

def xzProj(vector):
	"""Return the projection of vector onto the x-z plane"""
	return np.array([vector[0], 0, vector[2]])

def yzProj(vector):
	"""Return the projection of vector onto the y-z plane"""
	return np.array([0, vector[1], vector[2]])

def xyProj(vector):
	"""Return the projection of vector onto the x-y plane"""
	return np.array([vector[0], vector[1], 0])

def xzz(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the z axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[0] < 0:
			return -1*theta
		return theta
	else:
		return 0


def xzx(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the x axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[2] > 0:
			return -1*theta
		return theta
	else:
		return proj

def yzz(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the z axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[1] > 0:
			return -1*theta
		return theta
	else:
		return 0

def yzy(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the y axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[2] < 0:
			return -1*theta
		return theta
	else:
		return 0

def xyy(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the y axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[0] > 0:
			return -1*theta
		return theta
	else:
		return 0

def xyx(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the x axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[1] < 0:
			return -1*theta
		return theta
	else:
		return 0

def align2x(vectorSet, vector):
	"""Return a new set of vectors generated by rotating every member of vectorSet through the same rotation needed to align vector with x"""
	rx = Rx(-1*yzy(vector))
	newSet = [np.inner(rx, v) for v in vectorSet]
	vector = np.inner(rx, vector)
	return [np.inner(Rz(-1*xyx(vector)), v) for v in newSet]
					 
def angle(v1, v2):
	"""Return the angle between v1 and v2"""
	return np.arccos(np.dot(v1,v2)/(la.norm(v1)*la.norm(v2)))
					 
def distance(a, b):
	"""Calculate the distance between two vectors, ||a-b||"""
	return np.abs(la.norm(np.array(a) - np.array(b)))

def angles(number):
	"""generate a list of number equally spaced angles between 0 and 2pi"""
	return np.linspace(0, 2*pi, number, endpoint=False)

def genYrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the y-axis and which is orthogonal to y"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Ry(angle), vector)))
	return vectors

def genXrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the x-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rx(angle), vector)))
	return vectors

def genZrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the z-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rz(angle), vector)))
	return vectors

def X(vectors):
	"""Take a list of vectors and return a list of the x-components of the vectors"""
	return np.array([x for x,y,z in vectors])

def Y(vectors):
	"""Take a list of vectors and return a list of the y-components of the vectors"""
	return np.array([y for x,y,z in vectors])

def Z(vectors):
	"""Take a list of vectors and return a list of the z-components of the vectors"""
	return np.array([z for x,y,z in vectors])

def seek(start, end, translations):
	"""Given two points in space, attempt to crawl from one point to the other using only the moves given by the vectors in translations.
	If you can reach the other point, return the path taken, otherwise return false."""
	i=0
	position = np.array(start)
	end = np.array(end)
	togo = distance(start, end)
	translations = [np.array(v) for v in translations]
	path = [position]
	moves = []
	for translation in translations:
		moves.append(translation)
		moves.append(-1*translation)
	while True:
		moved = False
		for move in moves:
			trialPosition = position + move
			if distance(trialPosition, end) < togo:
				position = trialPosition
				path.append(position)
				togo = distance(position, end)
				moved = True
		if not moved:
			break
		i+=1
		if i > 100:
			print '100 move limit reached.'
			return False
		return path


def genOp(axis, op):
	"""Given a symmetry element (axis), generate a set of matrices representing the given symmetry operation (zOp) about the element."""	
	theta = xzz(axis)
	ry = Ry(-1*theta)
	wyz = np.inner(ry,axis)
	phi = yzz(wyz)
	rx = Rx(-1*phi)
	toZ = np.matmul(rx,ry)
	fromZ = la.inv(toZ)
	return np.matmul(fromZ,np.matmul(op,toZ))

def cullOps(ops):
	"""Given a list of matrices, remove any duplicates and return the uniques"""
	tmpOps = []
	for op in ops:
		dupe = False
		for tmpOp in tmpOps:
			if np.allclose(op,tmpOp):
				dupe = True
		if not dupe:
			tmpOps.append(op)
	return tmpOps
	

def fillBox(translations, basis):
	"""For a given set of lattice translations and basis atoms, generate a 3x3x3 supercell"""
	atoms = []
	for vx in [-translations[0], zeroVector, translations[0]]:
		for vy in [-translations[1], zeroVector, translations[1]]:
			for vz in [-translations[2], zeroVector, translations[2]]:
				for b in basis:
					atoms.append([b[0],vx + vy + vz + b[1]])
	return atoms

def findMatch(box, atom):
	"""Search list of atoms (box) for an atom which is the same type and at the same position as the given atom"""
	shortestDistance = 5
	points = []
	for point in box:
		dist = distance(point[1],atom[1])
		if point[0] is atom[0] and distance(point[1],atom[1]) < 1e-5:
			return True
	'''
		elif point[0] is atom[0] and dist < shortestDistance:
			shortestDistance = dist
			points = [atom,point]
	print 'Failed to connect points: %s' % points
	'''
	return False	
		
	
M = {'1'	:	np.array([[1,0,0], [0,1,0], [0,0,1]]),
	 '-1'	:	np.array([[-1,0,0], [0,-1,0], [0,0,-1]]),
	 '2'	:	np.array([[-1,0,0], [0,-1,0], [0,0,1]]),
	 '3'	:	np.array([[-0.5,-0.5*np.sqrt(3),0], [0.5*np.sqrt(3),-0.5,0], [0,0,1]]),
	 '-3'	:	np.array([[0.5,0.5*np.sqrt(3),0], [-0.5*np.sqrt(3),0.5,0], [0,0,-1]]),
	 '4'	:	np.array([[0,-1,0], [1,0,0], [0,0,1]]),
	 '-4'	:	np.array([[0,1,0], [-1,0,0], [0,0,-1]]),
	 '6'	:	np.array([[0.5,-0.5*np.sqrt(3),0], [0.5*np.sqrt(3),0.5,0], [0,0,1]]),
	 '-6'	:	np.array([[-0.5,0.5*np.sqrt(3),0], [-0.5*np.sqrt(3),-0.5,0], [0,0,-1]]),
	 'm'	:	np.array([[1,0,0], [0,1,0], [0,0,-1]]),
	 }

pointGroups = {'1':{'symOps': False,
			   'system':'triclinic',
			   'order':1},
		  '-1':{'symOps':[{'axis':0,'type':'rotoinversion','order':1}],
				'system':'triclinic',
			    'order':2},
		  '2':{'symOps': [{'axis':0,'type':'rotation','order':2}],
			   'system':'monoclinic',
			   'order':2},
		  'm':{'symOps': [{'axis':0,'type':'reflection'}],
			   'system':'monoclinic',
			   'order':2},
		  '2/m':{'symOps': [{'axis':0,'type':'rotation','order':2},
						   {'axis':0,'type':'reflection'}],
				 'system':'monoclinic',
			     'order':4},
		  '222':{'symOps': [{'axis':0,'type':'rotation','order':2},
						    {'axis':1,'type':'rotation','order':2},
						    {'axis':2,'type':'rotation','order':2}], 
				 'system':'orthorhombic',
			     'order':4},
		  'mm2':{'symOps': [{'axis':0,'type':'reflection'},
							{'axis':1,'type':'reflection'},
							{'axis':2,'type':'rotation','order':2}],
				 'system':'orthorhombic',
			     'order':4},
		  '2/m2/m2/m':{'symOps': [{'axis':0,'type':'rotation','order':2},
							{'axis':0,'type':'reflection'},
						   	{'axis':1,'type':'rotation','order':2},
						   	{'axis':1,'type':'reflection'},
							{'axis':2,'type':'rotation','order':2},
						   	{'axis':2,'type':'reflection'}],
				 'system':'orthorhombic',
			     'order':8},
		  '3':{'symOps': [{'axis':0,'type':'rotation','order':3}],
			   'system':'trigonal',
			   'order':3},
		  '-3':{'symOps': [{'axis':0,'type':'rotoinversion','order':3}],
			   'system':'trigonal',
			   'order':6},
		  '32':{'symOps': [{'axis':0,'type':'rotation','order':3},
						   {'axis':1,'type':'rotation','order':2}],
			   'system':'trigonal',
			   'order':6},
		  '3m':{'symOps': [{'axis':0,'type':'rotation','order':3},
						   {'axis':1,'type':'reflection'}],
			   'system':'trigonal',
			    'order':6},
		  '-32/m':{'symOps':[{'axis':0,'type':'rotoinversion','order':3},
							 {'axis':1,'type':'rotation','order':2},
						     {'axis':1,'type':'reflection'}],
			   'system':'trigonal',
			   'order':12},
		  '4':{'symOps': [{'axis':0,'type':'rotation','order':4}],
			   'system':'tetragonal',
			   'order':4},
		  '-4':{'symOps': [{'axis':0,'type':'rotoinversion','order':4}],
			   'system':'tetragonal',
			   'order':4},
		  '4/m':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':0,'type':'reflection'}],
			   'system':'tetragonal',
			   'order':8},
		  '422':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':1,'type':'rotation','order':2},
						    {'axis':2,'type':'rotation','order':2}],
			   'system':'tetragonal',
			   'order':8},
		  '4mm':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':1,'type':'reflection'},
						    {'axis':2,'type':'reflection'}],
			   'system':'tetragonal',
			   'order':8},
		  '-42m':{'symOps': [{'axis':0,'type':'rotoinversion','order':4},
						     {'axis':1,'type':'rotation','order':2},
						     {'axis':2,'type':'reflection'}],
			   'system':'tetragonal',
			   'order':8},
		  '4/m2/m2/m':{'symOps':[{'axis':0,'type':'rotation','order':4},
						    	 {'axis':0,'type':'reflection'},
						    	 {'axis':1,'type':'rotation','order':2},
							 	 {'axis':1,'type':'reflection'},
						     	 {'axis':2,'type':'rotation','order':2},
						     	 {'axis':2,'type':'reflection'}],
			   'system':'tetragonal',
			   'order':16},
		  '6':{'symOps':[{'axis':0,'type':'rotation','order':6}],
			   'system':'hexagonal',
			   'order':6},
		  '-6':{'symOps':[{'axis':0,'type':'rotoinversion','order':6}],
			   'system':'hexagonal',
			   'order':6},
		  '6/m':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':0,'type':'reflection'}],
			   'system':'hexagonal',
			   'order':12},
		  '622':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':1,'type':'rotation','order':2},
						   {'axis':2,'type':'rotation','order':2}],
			   'system':'hexagonal',
			   'order':12},
		  '6mm':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':1,'type':'reflection'},
						   {'axis':2,'type':'reflection'}],
			   'system':'hexagonal',
			   'order':12},
		  '-6m2':{'symOps':[{'axis':0,'type':'rotoinversion','order':6},
						    {'axis':1,'type':'reflection'},
						    {'axis':2,'type':'rotation','order':2}],
			   'system':'hexagonal',
			   'order':12},
		  '6/m2/m2/m':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   		 {'axis':0,'type':'reflection'},
						   		 {'axis':1,'type':'rotation','order':2},
								 {'axis':1,'type':'reflection'},
								 {'axis':2,'type':'rotation','order':2},
								 {'axis':2,'type':'reflection'}],
			   'system':'hexagonal',
			   'order':24},
		  '23':{'symOps':[{'axis':0,'type':'rotation','order':2},
						  {'axis':1,'type':'rotation','order':3}],
			   'system':'cubic',
			   'order':12},
		  '2/m-3':{'symOps':[{'axis':0,'type':'rotation','order':2},
						     {'axis':0,'type':'reflection'},
							 {'axis':1,'type':'rotoinversion','order':3}],
			   'system':'cubic',
			   'order':24},
		  '432':{'symOps':[{'axis':0,'type':'rotation','order':4},
						   {'axis':1,'type':'rotation','order':3},
						   {'axis':2,'type':'rotation','order':2}],
			   'system':'cubic',
			   'order':24},
		  '-43m':{'symOps':[{'axis':0,'type':'rotoinversion','order':4},
						    {'axis':1,'type':'rotation','order':3},
							{'axis':2,'type':'reflection'}],
			   'system':'cubic',
			   'order':24},
		  '4/m-32/m':{'symOps':[{'axis':0,'type':'rotation','order':4},
								{'axis':0,'type':'reflection'},
								{'axis':1,'type':'rotoinversion','order':3},
								{'axis':2,'type':'rotation','order':2},
								{'axis':2,'type':'reflection'}],
			   'system':'cubic',
			   'order':48},
		 }

class Crystal:
	"""Given a set of lattice translation vectors and a basis, this will return an object describing the lattice and reciprocal lattice."""
	def __init__(self, translations, basis):
		self.translations = [np.array(v) for v in translations]
		self.basis = [[b[0],np.array(b[1])] for b in basis]
		self.directGroup = False
		self.system = False
		self.pgAxes = False
		self.pgOps = []
		self.pointGroup = False
	def findSystem(self):
		v0, v1, v2 = self.translations
		if np.absolute(np.dot(v0,v1)) > 1e-9 or np.absolute(np.dot(v1,v2)) > 1e-9 or np.absolute(np.dot(v0,v2)) > 1e-9: #if there is a non-right angle
			if np.absolute(la.norm(v0) - la.norm(v1)) < 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) < 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) < 1e-9: # if any two sides are of equal length
				if np.absolute(np.dot(v0, v1)) < 1e-9 or np.absolute(np.dot(v1,v2)) < 1e-9 or np.absolute(np.dot(v0, v2)) < 1e-9: #if there are any right angles
					if np.absolute(angle(v0,v1) - 2*pi/3) < 1e-9 or np.absolute(angle(v1,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v1) - pi/3) < 1e-9 or np.absolute(angle(v1,v2) - pi/3) < 1e-9 or np.absolute(angle(v0,v2) - pi/3) < 1e-9: #if any of the angles are 120 or 60
						self.system = 'hexagonal'
						if np.absolute(angle(v0,v1) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v1) - pi/3) < 1e-9:
							self.pgAxes = [[v2]]
							self.pgAxes.append([v0,v1])
							self.pgAxes.append([v0+v1,v0-v1])
						elif np.absolute(angle(v0,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v2) - pi/3) < 1e-9:
							self.pgAxes = [[v1]]
							self.pgAxes.append([v0,v2])
							self.pgAxes.append([v0+v2,v0-v2])
						else:
							self.pgAxes = [[v0]]
							self.pgAxes.append([v1,v2])
							self.pgAxes.append([v1+v2,v1-v2])
						print 'z-axes: %s' % self.pgAxes[0]
					else:
						self.system = 'monoclinic'
						if np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v0,v2)) < 1e-9: #if translation vector 0 is at right angles to 1 and 2, vector 0 is the high symmetry axis used for point group operations
							self.pgAxes = [[v0]]
						elif np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v1,v2)) < 1e-9:
							self.pgAxes = [[v1]]
						else:
							self.pgAxes = [[v2]]
				else:
					if np.absolute(angle(v0,v1)) - np.absolute(angle(v1,v2)) < 1e-9 and np.absolute(angle(v0,v1)) - np.absolute(angle(v0,v2)) < 1e-9: #if all the angles are the same
						self.system = 'trigonal'
						ax0 = v0 + v1 + v2
						self.pgAxes = [[ax0]]
						ax1 = np.cross(v0+v1+v2,v1-v2)
						ax2 = np.cross(ax0,ax1)
						self.pgAxes.append([ax1,ax2])
						
					else:
						print 'Unable to decipher cystal system'
			else:
				if np.absolute(np.dot(v0, v1)) < 1e-9 or np.absolute(np.dot(v1,v2)) < 1e-9 or np.absolute(np.dot(v0, v2)) < 1e-9: #if there are any right angles
					self.system = 'monoclinic'
					if np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v0,v2)) < 1e-9: #if translation vector 0 is at right angles to 1 and 2, vector 0 is the high symmetry axis used for point group operations
						self.pgAxes = [[v0]]
					elif np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v1,v2)) < 1e-9:
						self.pgAxes = [[v1]]
					else:
						self.pgAxes = [[v2]]
				else:
					self.system = 'triclinic'
		elif np.absolute(la.norm(v0) - la.norm(v1)) > 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) > 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) > 1e-9: # if any two sides are of unequal length
			if np.absolute(la.norm(v0) - la.norm(v1)) < 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) < 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) < 1e-9: # if any two sides are of equal length
				self.system = 'tetragonal'
				if np.absolute(la.norm(v0)) - np.absolute(la.norm(v1)) < 1e-9: #if v2 is a different lenth than the others
					self.pgAxes = [[v2]]
					self.pgAxes.append([v0,v1])
					self.pgAxes.append([v0+v1,v0-v1])
				elif np.absolute(la.norm(v0)) - np.absolute(la.norm(v2)) < 1e-9:
					self.pgAxes = [[v1]]
					self.pgAxes.append([v0,v2])
					self.pgAxes.append([v0+v2,v0-v2])
				else:
					self.pgAxes = [[v0]]
					self.pgAxes.append([v1,v2])
					self.pgAxes.append([v1+v2,v1-v2])
			else:
				self.system = 'orthorhombic'
				self.pgAxes = [[v0],[v1],[v2]]
		else:
			self.system = 'cubic'
			self.pgAxes = [[v0,v1,v2]]
			self.pgAxes.append([v0+v1+v2, v1+v2-v0, v0+v2-v1, v0+v1-v2])
			self.pgAxes.append([v0+v1, v0+v2, v1+v2])
	def findPointGroup(self):
		groupMatches = []
		highestOrder = 0
		if not self.system:
			return False
		for name, pg in pointGroups.iteritems():
			tmpOps = [M['1']]
			zero1ops = [M['1']]
			zero2ops = [M['1']]
			one1ops = [M['1']]
			one2ops = [M['1']]
			two1ops = [M['1']]
			two2ops = [M['1']]
			if pg['system'] is self.system:
				#print 'checking point group %s' % name
				for op in pg['symOps']:
					if op['axis'] is 0:
						for axis in self.pgAxes[0]:
							if op['type'] is 'reflection':
								zero1ops.append(genOp(axis,M['m']))
							if op['type'] is 'rotation' or op['type'] is 'rotoinversion':
								mOp = '-'+str(op['order']) if op['type'] is 'rotoinversion' else str(op['order'])
								for n in range(1,op['order']):
									zero2ops.append(la.matrix_power(genOp(axis,M[mOp]),n))
				for op1 in zero1ops:
					for op2 in zero2ops:
						tmpOps.append(np.matmul(op1,op2))
						tmpOps.append(np.matmul(op2,op1))
				tmpOps = cullOps(tmpOps)
				for op in pg['symOps']:
					if op['axis'] is 1:
						for axis in self.pgAxes[1]:
							if op['type'] is 'reflection':
								one1ops.append(genOp(axis,M['m']))
							if op['type'] is 'rotation' or op['type'] is 'rotoinversion':
								mOp = '-'+str(op['order']) if op['type'] is 'rotoinversion' else str(op['order'])
								for n in range(1,op['order']):
									one2ops.append(la.matrix_power(genOp(axis,M[mOp]),n))
				tmpOps2 = []
				for op1 in one1ops:
					for op2 in one2ops:
						tmpOps2.append(np.matmul(op1,op2))
						tmpOps2.append(np.matmul(op2,op1))
				tmpOps2 = cullOps(tmpOps2)
				tmpOps3 = copy.deepcopy(tmpOps)
				for op1 in tmpOps3:
					for op2 in tmpOps2:
						tmpOps.append(np.matmul(op1,op2))
						tmpOps.append(np.matmul(op2,op1))	
					tmpOps = cullOps(tmpOps)
				for op in pg['symOps']:
					if op['axis'] is 2:
						for axis in self.pgAxes[2]:
							if op['type'] is 'reflection':
								two1ops.append(genOp(axis,M['m']))
							if op['type'] is 'rotation' or op['type'] is 'rotoinversion':
								mOp = '-'+str(op['order']) if op['type'] is 'rotoinversion' else str(op['order'])
								for n in range(1,op['order']):
									two2ops.append(la.matrix_power(genOp(axis,M[mOp]),n))									
				tmpOps2 = []
				for op1 in two1ops:
					for op2 in two2ops:
						tmpOps2.append(np.matmul(op1,op2))
						tmpOps2.append(np.matmul(op2,op1))
				tmpOps2 = cullOps(tmpOps2)
				tmpOps3 = copy.deepcopy(tmpOps)
				for op1 in tmpOps3:
					for op2 in tmpOps2:
						tmpOps.append(np.matmul(op1,op2))
						tmpOps.append(np.matmul(op2,op1))
					tmpOps = cullOps(tmpOps)
				#print 'point group: %s' % name
				#print 'tmpOps before cull: %i' % len(tmpOps)
				tmpOps = cullOps(tmpOps)
				print 'checking point group %s with %i symmetry operations:' % (name, len(tmpOps))
				box = fillBox(self.translations, self.basis)
				isMatch = True
				matchedOps = []
				for op in tmpOps:
					for t in self.translations:
						for b in self.basis:
							v = np.matmul(op,t+b[1])
							#print 'operating on vector: %s' % v
							#w = seek(np.matmul(op,t+b[1]), zeroVector, self.translations)[-1]
							w = seek(v, zeroVector, self.translations)[-1]
							#print 'centered to vector: %s' % w
							if not findMatch(box,[b[0], w]):
								isMatch = False
					if isMatch:
						matchedOps.append(op)
				print '%i matches found\n' % len(matchedOps)
				if isMatch:
					if self.pointGroup:
						if pg['order'] > pointGroups[self.pointGroup]['order']:
							self.pointGroup = name
							self.pgOps = copy.deepcopy(tmpOps)
					else:
						self.pointGroup = name
						self.pgOps = copy.deepcopy(tmpOps)
				else:
					matchedOps = cullOps(matchedOps)
					if len(matchedOps) > len(self.pgOps):
						self.pgOps = matchedOps
'''
#Nickel Arsenide
translations = np.array([[1.0, 0.0, 0.0],
				[0.5, 0.5*np.sqrt(3), 0.0],
				[0.0, 0.0, 1.0]])
basis = [['Ni',[0.0,0.0,0.0]], ['As',[0.5,0.5/np.sqrt(3),0.5]], ['As',[0,1.0/np.sqrt(3),0.5]]]
'''

#Cadmium Telluride
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = [['Cd',[0.0,0.0,0.0]], ['Cd',[0.0,0.5,0.5]], ['Cd',[0.5,0.0,0.5]], ['Cd',[0.5,0.5,0.0]], ['Te',[0.25,0.25,0.25]], ['Te',[0.25,0.75,0.75]], ['Te',[0.75,0.25,0.75]], ['Te',[0.75,0.75,0.25]]]

'''
#NaCl
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = [['Na',[0.0,0.0,0.0]], ['Na',[0.0,0.5,0.5]], ['Na',[0.5,0.0,0.5]], ['Na',[0.5,0.5,0.0]], ['Cl',[0.5,0.0,0.0]], ['Cl',[0.5,0.5,0.5]], ['Cl',[1.0,0.0,0.5]], ['Cl',[1.0,0.5,0.0]]]
'''
'''
#Si primitive cell
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = []
vectors = [[0.0,0.0,0.0],[0.5,0.5,0.0],[0.5,0.0,0.5],[0.0,0.5,0.5]]
for atom in vectors:
	basis.append(['Si',atom])
for atom in vectors[1:]: # w/vacancy
#for atom in vectors: # w/o vacancy
	basis.append(['Si',[x+0.25 for x in atom]])
'''	

crystal = Crystal(translations, basis)
crystal.findSystem()
print 'Crystal matched to %s lattice system' % crystal.system
print '-------------------------------------------------------------'
crystal.findPointGroup()
print '-------------------------------------------------------------'
if crystal.pointGroup:
	print 'Success! The point group for this crystal is %s' % crystal.pointGroup
else:
	print 'Point group match not found'
print '%i symmetry operations found' % len(crystal.pgOps)

'''
start = [-2.0,0.5,0.0]
end = [0.0,0.0,0.0]
print str(seek(start, end, translations)[-1])
'''
'''
op = genOp([1,0,0], M['m'])
box = fillBox(translations, basis)
#for atom in box:
#	print atom
for n in range(0,4):
	v = basis[2]
	print '%i-fold rotation' % n
	print 'inital position: ' % v[1]
	w = np.matmul(la.matrix_power(op,n),v[1])
	print 'position: %s' % w
	if findMatch(box, [v[0],w]):
		print 'match found'
	else:
		print 'failed'
'''





'''
plt.ion()
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d', xlabel='x', ylabel='y', zlabel='z')
ax.plot(X([zeroVector,v0]), Y([zeroVector,v0]), Z([zeroVector,v0]), color='b')
ax.plot(X([zeroVector,v1]), Y([zeroVector,v1]), Z([zeroVector,v1]), color='b')
ax.plot(X([zeroVector,v2]), Y([zeroVector,v2]), Z([zeroVector,v2]), color='b')
ax.plot(X([zeroVector,axis1]), Y([zeroVector,axis1]), Z([zeroVector,axis1]), color='g')
ax.plot(X([zeroVector,axis2]), Y([zeroVector,axis2]), Z([zeroVector,axis2]), color='r')
ax.plot(X([v0,v2]), Y([v0,v2]), Z([v0,v2]), color='k')
plt.show()
raw_input('Press enter to continue.')
'''







'''
path = seek([0.0, 0.0, 0.0], [6.5, 2.0, 3.5], translations)
if path:
	plt.ion()
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d', xlabel='x', ylabel='y', zlabel='z')
	#ax.scatter(X(vectors), Y(vectors), Z(vectors), s=100)
	ax.plot(X(path), Y(path), Z(path))
	plt.show()
	raw_input('Press enter to continue.')
else:
	print 'Coincident site not found'
'''
	