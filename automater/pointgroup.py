from compatibility import *
from collections import OrderedDict
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from random import randint
import numpy.linalg as la
import numpy as np
import copy
import re
from ase import io as aseio
from ase import Atoms as aseatoms
import ase
import elements
import os 

pi = np.pi
xHat = np.array([1.0, 0.0, 0.0])
yHat = np.array([0.0, 1.0, 0.0])
zHat = np.array([0.0, 0.0, 1.0])
zeroVector = np.array([0.0,0.0,0.0])
verbosity = 'monk'

class GenericClass(object):
	pass

class ArrayList():
	"""Base class for lists of arrays, including some basic methods for adding arrays, adding information about the arrays, and referencing the arrays. """
	def __init__(self):
		self.dict = {} # Main dictionary of arrays. Minimum structure for entry is {'NAME':{'matrix':np.array[...]}}
		self.length = 0
	def add(self, ref=False, array=[], dataDict = {}):
		"""Adds an array to the dictionary, with any additional data as given in dataDict"""
		if not (ref and len(array)):
			print('In order to add an element to an arrayList using addArray, you must provide a reference name and an array')
			return False
		self.dict[ref] = {'matrix':array}
		for key, value in iteritems(dataDict):
			self.dict[ref][key] = value
		self.update()
	def arrays(self):
		"""Return a list of the arrays in the dictionary"""
		arrList = []
		for key, value in iteritems(self.dict):
			arrList.append(value['matrix'])
		return arrList
	def addUnique(self, ref=False, newArray=[], dataDict={}):
		"""If array is not already in the dictionary, add it. Return False if it is a duplicate"""
		if not (ref and len(newArray)):
			print('In order to add an element to an arrayList using addArray, you must provide a reference name and an array')
			return False
		dupe = False
		for oldArray in self.arrays():
			if np.allclose(newArray,oldArray):
				dupe = True
				break
		if not dupe:
			self.add(ref, newArray, dataDict)
			return True
		return False
	def update(self):
		"""Update various data regarding the array list."""
		self.length = len(self.dict)
	def array(self, ref):
		"""Return the array named ref from the dictionary"""
		if ref in self.dict.keys():
			return self.dict[ref]['matrix']
		return False
	def blend(self, newRef=False, newArray=[], dataDict={}):
		"""Add any unique arrays generated by combining the given array with all each array in the dictionary using matrix multiplication. Return any new arrays added to the dictionary"""
		if not (newRef and len(newArray)):
			print('In order to add an element to an arrayList using addArray, you must provide a reference name and an array')
			return False
		returnDict = {}
		for oldRef, oldArray in iteritems(copy.deepcopy(self.dict)):
			trialRef = oldRef+newRef
			trialArray = np.matmul(newArray, oldArray['matrix'])
			if self.addUnique(trialRef, trialArray, dataDict):
				returnDict[trialRef] = trialArray
			trialRef = newRef+oldRef
			trialArray = np.matmul(oldArray['matrix'], newArray)
			if self.addUnique(trialRef, trialArray, dataDict):
				returnDict[trialRef] = trialArray
		return returnDict
			
			

def Ry(theta):
	"""Generates a matrix which will rotate a vector about the y-axis by theta degrees"""
	return np.array([[np.cos(theta), 0, np.sin(theta)],
					 [0, 1, 0],
					 [-1*np.sin(theta), 0, np.cos(theta)]])

def Rz(theta):
	"""Generates a matrix which will rotate a vector about the z-axis by theta degrees"""
	return np.array([[np.cos(theta), -1*np.sin(theta), 0],
				[np.sin(theta), np.cos(theta), 0],
				[0, 0, 1]])

def Rx(theta):
	"""Generates a matrix which will rotate a vector about the x-axis by theta degrees"""
	return np.array([[1, 0, 0],
					[0, np.cos(theta), -1*np.sin(theta)],
					[0, np.sin(theta), np.cos(theta)]])

def xzProj(vector):
	"""Return the projection of vector onto the x-z plane"""
	return np.array([vector[0], 0, vector[2]])

def yzProj(vector):
	"""Return the projection of vector onto the y-z plane"""
	return np.array([0, vector[1], vector[2]])

def xyProj(vector):
	"""Return the projection of vector onto the x-y plane"""
	return np.array([vector[0], vector[1], 0])

def xzz(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the z axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[0] < 0:
			return -1*theta
		return theta
	else:
		return 0


def xzx(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the x axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[2] > 0:
			return -1*theta
		return theta
	else:
		return proj

def yzz(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the z axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[1] > 0:
			return -1*theta
		return theta
	else:
		return 0

def yzy(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the y axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[2] < 0:
			return -1*theta
		return theta
	else:
		return 0

def xyy(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the y axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[0] > 0:
			return -1*theta
		return theta
	else:
		return 0

def xyx(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the x axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[1] < 0:
			return -1*theta
		return theta
	else:
		return 0

def align2x(vectorSet, vector):
	"""Return a new set of vectors generated by rotating every member of vectorSet through the same rotation needed to align vector with x"""
	rx = Rx(-1*yzy(vector))
	newSet = [np.inner(rx, v) for v in vectorSet]
	vector = np.inner(rx, vector)
	return [np.inner(Rz(-1*xyx(vector)), v) for v in newSet]
					 
def angle(v1, v2):
	"""Return the angle between v1 and v2"""
	return np.arccos(np.dot(v1,v2)/(la.norm(v1)*la.norm(v2)))
					 
def distance(a, b):
	"""Calculate the distance between two vectors, ||a-b||"""
	return np.abs(la.norm(np.array(a) - np.array(b)))

def angles(number):
	"""generate a list of number equally spaced angles between 0 and 2pi"""
	return np.linspace(0, 2*pi, number, endpoint=False)

def genYrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the y-axis and which is orthogonal to y"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Ry(angle), vector)))
	return vectors

def genXrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the x-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rx(angle), vector)))
	return vectors

def genZrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the z-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rz(angle), vector)))
	return vectors

def X(vectors):
	"""Take a list of vectors and return a list of the x-components of the vectors"""
	return np.array([x for x,y,z in vectors])

def Y(vectors):
	"""Take a list of vectors and return a list of the y-components of the vectors"""
	return np.array([y for x,y,z in vectors])

def Z(vectors):
	"""Take a list of vectors and return a list of the z-components of the vectors"""
	return np.array([z for x,y,z in vectors])

def seek(start, end, translations):
	"""Given two points in space, attempt to crawl from one point to the other using only the moves given by the vectors in translations.
	Return a list of points on the path taken"""
	i=0
	position = np.array(start)
	end = np.array(end)
	togo = distance(start, end)
	translations = [np.array(v) for v in translations]
	path = [position]
	moves = []
	for translation in translations:
		moves.append(translation)
		moves.append(-1*translation)
	while True:
		moved = False
		for move in moves:
			trialPosition = position + move
			if distance(trialPosition, end) < togo:
				position = trialPosition
				path.append(position)
				togo = distance(position, end)
				moved = True
		if not moved:
			break
		i+=1
		if i > 100:
			print('100 move limit reached.')
			return False
	return path


def genOp(axis, op):
	"""Given a symmetry element (axis), generate a set of matrices representing the given symmetry operation (zOp) about the element."""	
	theta = xzz(axis)
	ry = Ry(-1*theta)
	wyz = np.inner(ry,axis)
	phi = yzz(wyz)
	rx = Rx(-1*phi)
	toZ = np.matmul(rx,ry)
	fromZ = la.inv(toZ)
	return np.matmul(fromZ,np.matmul(op,toZ))

def genSymOps(opType, axis, order=False):
	"""Generate a dictionary of matrices representing rotations about the given axis angles of n*(360/order) where n = 1,...,order. Dictionary keys are n."""
	rots = {}
	if opType == 'rotation' or opType == 'rotoinversion':
		if not order:
			print('To generate a list of rotations with genSymOps(), you must provide a third argument indicating the order of the rotation')
			return False
		mOp = '-'+str(order) if opType == 'rotoinversion' else str(order)
		for n in range(1,order):
			rots['[%i/%s]' % (n,mOp)] = la.matrix_power(genOp(axis,M.array(mOp)),n)
	elif opType == 'reflection':
		rots['m'] = genOp(axis,M.array('m'))
	return rots

def cullOps(ops):
	"""Given a list of matrices, remove any duplicates and return the uniques"""
	tmpOps = []
	for op in ops:
		dupe = False
		for tmpOp in tmpOps:
			if np.allclose(op,tmpOp):
				dupe = True
		if not dupe:
			tmpOps.append(op)
	return tmpOps
	

def fillBox(translations, basis):
	"""For a given set of lattice translations and basis atoms, generate a 3x3x3 supercell"""
	atoms = []
	for vx in [-translations[0], zeroVector, translations[0]]:
		for vy in [-translations[1], zeroVector, translations[1]]:
			for vz in [-translations[2], zeroVector, translations[2]]:
				for b in basis:
					atoms.append([b[0],vx + vy + vz + b[1]])
	return atoms

def findMatch(box, atom):
	"""Search list of atoms (box) for an atom which is the same type and at the same position as the given atom"""
	shortestDistance = 5
	points = []
	for point in box:
		dist = distance(point[1],atom[1])
		if point[0] == atom[0] and distance(point[1],atom[1]) < 1e-5:
			return True
	return False	

# M is a list of matrix representations of basic operations about the z-axis
M = ArrayList()
M.add('1', np.array([[1,0,0], [0,1,0], [0,0,1]]), {'order':1, 'type':'rotation'})
M.add('-1', np.array([[-1,0,0], [0,-1,0], [0,0,-1]]), {'order':1, 'type':'rotoinversion'})
M.add('2', np.array([[-1,0,0], [0,-1,0], [0,0,1]]), {'order':2, 'type':'rotation'})
M.add('3', np.array([[-0.5,-0.5*np.sqrt(3),0], [0.5*np.sqrt(3),-0.5,0], [0,0,1]]), {'order':3, 'type':'rotation'})
M.add('-3', np.array([[0.5,0.5*np.sqrt(3),0], [-0.5*np.sqrt(3),0.5,0], [0,0,-1]]), {'order':3, 'type':'rotoinversion'})
M.add('4', np.array([[0,-1,0], [1,0,0], [0,0,1]]), {'order':4, 'type':'rotation'})
M.add('-4', np.array([[0,1,0], [-1,0,0], [0,0,-1]]), {'order':4, 'type':'rotoinversion'})
M.add('6', np.array([[0.5,-0.5*np.sqrt(3),0], [0.5*np.sqrt(3),0.5,0], [0,0,1]]), {'order':6, 'type':'rotation'})
M.add('-6', np.array([[-0.5,0.5*np.sqrt(3),0], [-0.5*np.sqrt(3),-0.5,0], [0,0,-1]]), {'order':6, 'type':'rotoinversion'})
M.add('m', np.array([[1,0,0], [0,1,0], [0,0,-1]]), {'order':1, 'type':'reflection'})

# pointGroups is a dictionary with basic information about the 32 point groups. Consider changing the structure of this to a custom class, or somehow changing it to an ArrayList obect
pointGroups = {'1':{'symOps': False,
			   'system':'triclinic',
			   'order':1},
		  '-1':{'symOps':[{'axis':0,'type':'rotoinversion','order':1}],
				'system':'triclinic',
			    'order':2},
		  '2':{'symOps': [{'axis':0,'type':'rotation','order':2}],
			   'system':'monoclinic',
			   'order':2},
		  'm':{'symOps': [{'axis':0,'type':'reflection','order':1}],
			   'system':'monoclinic',
			   'order':2},
		  '2/m':{'symOps': [{'axis':0,'type':'rotation','order':2},
						   {'axis':0,'type':'reflection','order':1}],
				 'system':'monoclinic',
			     'order':4},
		  '222':{'symOps': [{'axis':0,'type':'rotation','order':2},
						    {'axis':1,'type':'rotation','order':2},
						    {'axis':2,'type':'rotation','order':2}], 
				 'system':'orthorhombic',
			     'order':4},
		  'mm2':{'symOps': [{'axis':0,'type':'reflection','order':1},
							{'axis':1,'type':'reflection','order':1},
							{'axis':2,'type':'rotation','order':2}],
				 'system':'orthorhombic',
			     'order':4},
		  '2/m2/m2/m':{'symOps': [{'axis':0,'type':'rotation','order':2},
							{'axis':0,'type':'reflection','order':1},
						   	{'axis':1,'type':'rotation','order':2},
						   	{'axis':1,'type':'reflection','order':1},
							{'axis':2,'type':'rotation','order':2},
						   	{'axis':2,'type':'reflection','order':1}],
				 'system':'orthorhombic',
			     'order':8},
		  '3':{'symOps': [{'axis':0,'type':'rotation','order':3}],
			   'system':'trigonal',
			   'order':3},
		  '-3':{'symOps': [{'axis':0,'type':'rotoinversion','order':3}],
			   'system':'trigonal',
			   'order':6},
		  '32':{'symOps': [{'axis':0,'type':'rotation','order':3},
						   {'axis':1,'type':'rotation','order':2}],
			   'system':'trigonal',
			   'order':6},
		  '3m':{'symOps': [{'axis':0,'type':'rotation','order':3},
						   {'axis':1,'type':'reflection','order':1}],
			   'system':'trigonal',
			    'order':6},
		  '-32/m':{'symOps':[{'axis':0,'type':'rotoinversion','order':3},
							 {'axis':1,'type':'rotation','order':2},
						     {'axis':1,'type':'reflection','order':1}],
			   'system':'trigonal',
			   'order':12},
		  '4':{'symOps': [{'axis':0,'type':'rotation','order':4}],
			   'system':'tetragonal',
			   'order':4},
		  '-4':{'symOps': [{'axis':0,'type':'rotoinversion','order':4}],
			   'system':'tetragonal',
			   'order':4},
		  '4/m':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':0,'type':'reflection','order':1}],
			   'system':'tetragonal',
			   'order':8},
		  '422':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':1,'type':'rotation','order':2},
						    {'axis':2,'type':'rotation','order':2}],
			   'system':'tetragonal',
			   'order':8},
		  '4mm':{'symOps': [{'axis':0,'type':'rotation','order':4},
						    {'axis':1,'type':'reflection','order':1},
						    {'axis':2,'type':'reflection','order':1}],
			   'system':'tetragonal',
			   'order':8},
		  '-42m':{'symOps': [{'axis':0,'type':'rotoinversion','order':4},
						     {'axis':1,'type':'rotation','order':2},
						     {'axis':2,'type':'reflection','order':1}],
			   'system':'tetragonal',
			   'order':8},
		  '4/m2/m2/m':{'symOps':[{'axis':0,'type':'rotation','order':4},
						    	 {'axis':0,'type':'reflection','order':1},
						    	 {'axis':1,'type':'rotation','order':2},
							 	 {'axis':1,'type':'reflection','order':1},
						     	 {'axis':2,'type':'rotation','order':2},
						     	 {'axis':2,'type':'reflection','order':1}],
			   'system':'tetragonal',
			   'order':16},
		  '6':{'symOps':[{'axis':0,'type':'rotation','order':6}],
			   'system':'hexagonal',
			   'order':6},
		  '-6':{'symOps':[{'axis':0,'type':'rotoinversion','order':6}],
			   'system':'hexagonal',
			   'order':6},
		  '6/m':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':0,'type':'reflection','order':1}],
			   'system':'hexagonal',
			   'order':12},
		  '622':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':1,'type':'rotation','order':2},
						   {'axis':2,'type':'rotation','order':2}],
			   'system':'hexagonal',
			   'order':12},
		  '6mm':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   {'axis':1,'type':'reflection','order':1},
						   {'axis':2,'type':'reflection','order':1}],
			   'system':'hexagonal',
			   'order':12},
		  '-6m2':{'symOps':[{'axis':0,'type':'rotoinversion','order':6},
						    {'axis':1,'type':'reflection','order':1},
						    {'axis':2,'type':'rotation','order':2}],
			   'system':'hexagonal',
			   'order':12},
		  '6/m2/m2/m':{'symOps':[{'axis':0,'type':'rotation','order':6},
						   		 {'axis':0,'type':'reflection','order':1},
						   		 {'axis':1,'type':'rotation','order':2},
								 {'axis':1,'type':'reflection','order':1},
								 {'axis':2,'type':'rotation','order':2},
								 {'axis':2,'type':'reflection','order':1}],
			   'system':'hexagonal',
			   'order':24},
		  '23':{'symOps':[{'axis':0,'type':'rotation','order':2},
						  {'axis':1,'type':'rotation','order':3}],
			   'system':'cubic',
			   'order':12},
		  '2/m-3':{'symOps':[{'axis':0,'type':'rotation','order':2},
						     {'axis':0,'type':'reflection','order':1},
							 {'axis':1,'type':'rotoinversion','order':3}],
			   'system':'cubic',
			   'order':24},
		  '432':{'symOps':[{'axis':0,'type':'rotation','order':4},
						   {'axis':1,'type':'rotation','order':3},
						   {'axis':2,'type':'rotation','order':2}],
			   'system':'cubic',
			   'order':24},
		  '-43m':{'symOps':[{'axis':0,'type':'rotoinversion','order':4},
						    {'axis':1,'type':'rotation','order':3},
							{'axis':2,'type':'reflection','order':1}],
			   'system':'cubic',
			   'order':24},
		  '4/m-32/m':{'symOps':[{'axis':0,'type':'rotation','order':4},
								{'axis':0,'type':'reflection','order':1},
								{'axis':1,'type':'rotoinversion','order':3},
								{'axis':2,'type':'rotation','order':2},
								{'axis':2,'type':'reflection','order':1}],
			   'system':'cubic',
			   'order':48},
		 }

symPts = GenericClass()
symPts.fcc = GenericClass()
symPts.fcc.gamma = symPts.fcc.center = [0.,0.,0.]
symPts.fcc.X = symPts.fcc.chi = [0.,0.5,0.5]
symPts.fcc.L = [0.5,0.5,0.5]
symPts.fcc.W = [0.25,0.75,0.5]
symPts.fcc.U = [0.25,0.625,0.625]
symPts.fcc.K = symPts.fcc.kapps = [0.375,0.75,0.375]


class Crystal:
	"""Given a set of lattice translation vectors and a basis, this will return an object describing the lattice and reciprocal lattice."""
	def __init__(self, qeio, translations=[], basis=[]):
		self.qeio = qeio
		self.translations = [np.array(v) for v in translations]
		self.basis = [[b[0],np.array(b[1])] for b in basis]
		self.cell = False
		self.directGroup = False
		self.system = False
		self.pgAxes = False
		self.directOps = ArrayList()
		self.directOps.add('1', M.array('1'))
		self.pointGroup = False
		self.box = False
		self.a = False
		self.elements = OrderedDict()
	def cleanStart(self):
		self.translations = []
		self.basis = []
	'''
	def addElement(self,symbol,mass,pseudoFile=False):
		"""Add a reference for an element and it's corresponsing pseudopotential file. Mass in A.U. must also be entered"""
		if symbol not in self.elements:
			self.elements[symbol] = {}
		if mass:
			self.elements[symbol]['mass'] = mass
		if pseudoFile:
			self.elements[symbol]['pseudoFile'] = pseudoFile
	'''
	def addTranslation(self, t):
		"""Add a translation vector"""
		self.translations.append(np.array(t))
		if len(self.translations) > 3:
			print('You have defined more than three translations vectors.')
	def addAtom(self, element, v=[0.0,0.0,0.0], f=[1,1,1]):
		"""Add a basis atom"""
		self.basis.append([element, np.array(v), np.array(f)])
		if element not in self.elements:
			self.elements[element] = getattr(elements,element)
			self.qeio.pseudoChecked = False
	def removeAtom(self, element, position):
		"""Remove an atom based on position"""
		for i, atom in enumerate(self.basis):
			if distance(atom[1], position) < 1e-3 and atom[0] == element:
				self.basis.pop(i)
				return True
		return False
	def replaceAtom(self, element, replacement):
		"""Remove the first atom in self.crystal.basis of type element and replace with an atom of type replacement"""
		for i, atom in enumerate(self.basis):
			if atom[0] == element:
				self.basis[i][0] = replacement
				break
	def repeatStructure(self, t, n=1):
		"""Repeat the given structure n times along translation vector t, and adjust translation vector t as necessary for supercell. """
		atoms = copy.copy(self.basis)
		for j in range(1,n+1):
			for atom in atoms:
				self.addAtom(atom[0], atom[1] + j*self.translations[t], atom[2])
		self.translations[t] += n*self.translations[t]
	def printStructure(self):
		"""Print a list of atoms in the basis"""
		print('Lattice Constant: %f' % self.a)
		print ('Translation Vectors:')
		for v in self.translations:
			print(v)
		print('--------------------------------------------------\nAtoms:')
		for atom in self.basis:
			print('%s %f %f %f %i %i %i' % (atom[0], atom[1][0], atom[1][1], atom[1][2], atom[2][0], atom[2][1], atom[2][2]))
		print('--------------------------------------------------\n')
	def importStructure(self, path, index=None, format=None):
		"""create a structure from a .cif file"""
		structure = aseio.read(path, index=index, format=format)
		translations = structure.get_cell()
		self.a = la.norm(translations[0])
		self.translations = [np.array((1/self.a)*v) for v in translations]
		positions = structure.get_scaled_positions()
		symbols = structure.get_chemical_symbols()
		masses = structure.get_masses()
		for i in range(len(positions)):
			atom = positions[i]
			cartesian = atom[0]*self.translations[0] + atom[1]*self.translations[1] + atom[2]*self.translations[2]
			self.addAtom(symbols[i], cartesian)
	def exportStructure(self, importPath, importFormat, index=None, exportPath=False, exportFormat='cif'):
		"""Export crystallographic structure to file using ase"""
		structure = aseio.read(importPath, index=index, format=importFormat)
		if exportPath:
			aseio.write(exportPath, structure, format=exportFormat)
			return True
		else:
			print('You must provide a filepath for exporting')
			return False
	def findSystem(self):
		"""Attempt to match the given crystal translations vectors to one of the seven crystal systems"""
		if len(self.translations) < 3:
			print('Your crystal must have three translation vectors')
			return False
		v0, v1, v2 = self.translations
		if np.absolute(np.dot(v0,v1)) > 1e-9 or np.absolute(np.dot(v1,v2)) > 1e-9 or np.absolute(np.dot(v0,v2)) > 1e-9: #if there is a non-right angle
			if np.absolute(la.norm(v0) - la.norm(v1)) < 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) < 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) < 1e-9: # if any two sides are of equal length
				if np.absolute(np.dot(v0, v1)) < 1e-9 or np.absolute(np.dot(v1,v2)) < 1e-9 or np.absolute(np.dot(v0, v2)) < 1e-9: #if there are any right angles
					if np.absolute(angle(v0,v1) - 2*pi/3) < 1e-9 or np.absolute(angle(v1,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v1) - pi/3) < 1e-9 or np.absolute(angle(v1,v2) - pi/3) < 1e-9 or np.absolute(angle(v0,v2) - pi/3) < 1e-9: #if any of the angles are 120 or 60
						self.system = 'hexagonal'
						if np.absolute(angle(v0,v1) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v1) - pi/3) < 1e-9:
							self.pgAxes = [[v2]]
							self.pgAxes.append([v0,v1])
							self.pgAxes.append([v0+v1,v0-v1])
						elif np.absolute(angle(v0,v2) - 2*pi/3) < 1e-9 or np.absolute(angle(v0,v2) - pi/3) < 1e-9:
							self.pgAxes = [[v1]]
							self.pgAxes.append([v0,v2])
							self.pgAxes.append([v0+v2,v0-v2])
						else:
							self.pgAxes = [[v0]]
							self.pgAxes.append([v1,v2])
							self.pgAxes.append([v1+v2,v1-v2])
						print('z-axes: %s' % self.pgAxes[0])
					else:
						self.system = 'monoclinic'
						if np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v0,v2)) < 1e-9: #if translation vector 0 is at right angles to 1 and 2, vector 0 is the high symmetry axis used for point group operations
							self.pgAxes = [[v0]]
						elif np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v1,v2)) < 1e-9:
							self.pgAxes = [[v1]]
						else:
							self.pgAxes = [[v2]]
				else:
					if np.absolute(angle(v0,v1)) - np.absolute(angle(v1,v2)) < 1e-9 and np.absolute(angle(v0,v1)) - np.absolute(angle(v0,v2)) < 1e-9: #if all the angles are the same
						self.system = 'trigonal'
						ax0 = v0 + v1 + v2
						self.pgAxes = [[ax0]]
						ax1 = np.cross(v0+v1+v2,v1-v2)
						ax2 = np.cross(ax0,ax1)
						self.pgAxes.append([ax1,ax2])
						
					else:
						print('Unable to decipher cystal system')
			else:
				if np.absolute(np.dot(v0, v1)) < 1e-9 or np.absolute(np.dot(v1,v2)) < 1e-9 or np.absolute(np.dot(v0, v2)) < 1e-9: #if there are any right angles
					self.system = 'monoclinic'
					if np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v0,v2)) < 1e-9: #if translation vector 0 is at right angles to 1 and 2, vector 0 is the high symmetry axis used for point group operations
						self.pgAxes = [[v0]]
					elif np.absolute(np.dot(v0,v1)) < 1e-9 and np.absolute(np.dot(v1,v2)) < 1e-9:
						self.pgAxes = [[v1]]
					else:
						self.pgAxes = [[v2]]
				else:
					self.system = 'triclinic'
		elif np.absolute(la.norm(v0) - la.norm(v1)) > 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) > 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) > 1e-9: # if any two sides are of unequal length
			if np.absolute(la.norm(v0) - la.norm(v1)) < 1e-9 or np.absolute(la.norm(v1) - la.norm(v2)) < 1e-9 or np.absolute(la.norm(v0) - la.norm(v2)) < 1e-9: # if any two sides are of equal length
				self.system = 'tetragonal'
				if np.absolute(la.norm(v0)) - np.absolute(la.norm(v1)) < 1e-9: #if v2 is a different lenth than the others
					self.pgAxes = [[v2]]
					self.pgAxes.append([v0,v1])
					self.pgAxes.append([v0+v1,v0-v1])
				elif np.absolute(la.norm(v0)) - np.absolute(la.norm(v2)) < 1e-9:
					self.pgAxes = [[v1]]
					self.pgAxes.append([v0,v2])
					self.pgAxes.append([v0+v2,v0-v2])
				else:
					self.pgAxes = [[v0]]
					self.pgAxes.append([v1,v2])
					self.pgAxes.append([v1+v2,v1-v2])
			else:
				self.system = 'orthorhombic'
				self.pgAxes = [[v0],[v1],[v2]]
		else:
			self.system = 'cubic'
			self.pgAxes = [[v0,v1,v2]]
			self.pgAxes.append([v0+v1+v2, v1+v2-v0, v0+v2-v1, v0+v1-v2])
			self.pgAxes.append([v0+v1, v0+v2, v1+v2])
		if verbosity == 'teenage girl':
			if self.system:
				print('Crystal matched to %s system' % self.system)
			else:
				print('Unable to identify crystal system')
		return True
	def checkOp(self, opDef, checkAll=False):
		"""Check if the crystal is unchanged after given symmetry operation (op) about given axis"""
		returnVal = True
		for axisIndex, axis in enumerate(self.pgAxes[opDef['axis']]):
			axisOps = ArrayList()
			axisBool = True
			for testName, testOp in genSymOps(opDef['type'], axis, iteritems(opDef['order'])):
				testName = '%s(%i.%i)' % (testName, opDef['axis'], axisIndex)
				for atom in self.basis:
					if not findMatch(self.box, [atom[0], seek(np.matmul(testOp, atom[1]), zeroVector, self.translations)[-1]]):
						if not checkAll:
							return False
						returnVal = False
						axisBool = False
						break
					axisOps.add(testName, testOp)
			if axisBool:
				for n,o in iteritems(axisOps.dict):
					self.pgOps.blend(n, o['matrix'])
					self.directOps.blend(n, o['matrix'])
		return returnVal
	def findPointGroup(self, checkAll=False):
		"""Try to match the crystal to one of the 32 crystal point groups by checking symmetry operations. """
		if len(self.basis) < 1:
			print("You must add at least one basis atom")
			return False
		system = self.findSystem()
		if not system and not self.findSystem():
			return False
		self.box = fillBox(self.translations, self.basis)
		numOps = 0
		for name, pg in iteritems(pointGroups):
			self.pgOps = ArrayList()
			self.pgOps.add('1',M.array('1'))
			if pg['system'] == self.system: 
				match = True
				if verbosity == 'teenage girl':
					print('checking point group %s' % name)
				for opDef in pg['symOps']:
					if not self.checkOp(opDef, checkAll=checkAll):
						match = False
				if match:
					if pg['order'] > numOps:
						numOps = self.pgOps.length
						self.pointGroup = name

'''
#Nickel Arsenide
translations = np.array([[1.0, 0.0, 0.0],
				[0.5, 0.5*np.sqrt(3), 0.0],
				[0.0, 0.0, 1.0]])
basis = [['Ni',[0.0,0.0,0.0]], ['As',[0.5,0.5/np.sqrt(3),0.5]], ['As',[0,1.0/np.sqrt(3),0.5]]]
'''

'''
#Cadmium Telluride
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = [['Cd',[0.0,0.0,0.0]], ['Cd',[0.0,0.5,0.5]], ['Cd',[0.5,0.0,0.5]], ['Cd',[0.5,0.5,0.0]], ['Te',[0.25,0.25,0.25]], ['Te',[0.25,0.75,0.75]], ['Te',[0.75,0.25,0.75]], ['Te',[0.75,0.75,0.25]]]
#with vacancy
#basis = [['Cd',[0.0,0.0,0.0]], ['Cd',[0.0,0.5,0.5]], ['Cd',[0.5,0.0,0.5]], ['Cd',[0.5,0.5,0.0]], ['Te',[0.25,0.75,0.75]], ['Te',[0.75,0.25,0.75]], ['Te',[0.75,0.75,0.25]]]
#with centered vacancy
#basis = [['Cd',[0.0,0.5,0.5]], ['Cd',[0.5,0.0,0.5]], ['Cd',[0.5,0.5,0.0]], ['Te',[0.25,0.25,0.25]], ['Te',[0.25,0.75,0.75]], ['Te',[0.75,0.25,0.75]], ['Te',[0.75,0.75,0.25]]]
'''

'''
#NaCl
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = [['Na',[0.0,0.0,0.0]], ['Na',[0.0,0.5,0.5]], ['Na',[0.5,0.0,0.5]], ['Na',[0.5,0.5,0.0]], ['Cl',[0.5,0.0,0.0]], ['Cl',[0.5,0.5,0.5]], ['Cl',[1.0,0.0,0.5]], ['Cl',[1.0,0.5,0.0]]]
'''

'''
#Si primitive cell
translations = np.array([[1.0,0.0,0.0], [0.0,1.0,0.0], [0.0,0.0,1.0]])
basis = []
vectors = [[0.0,0.0,0.0],[0.5,0.5,0.0],[0.5,0.0,0.5],[0.0,0.5,0.5]]
for atom in vectors:
	basis.append(['Si',atom])
for atom in vectors[1:]: # w/vacancy
#for atom in vectors: # w/o vacancy
	basis.append(['Si',[x+0.25 for x in atom]])
'''	

if __name__ == '__main__':
	crystal = Crystal()
	#crystal.importStructure('C:/QuantumEspresso/structures/As.cif', format='cif')
	crystal.exportStructure(r'C:\QuantumEspresso\projects\As-primitive\vc-relax-op\vc-relax', 'espresso-out', -1, r'C:\QuantumEspresso\structures\as-primitive_vc-relax-2.cif', exportFormat='cif')
	'''
	verbosity = 'teenage girl'
	crystal = Crystal(translations, basis)
	crystal.findPointGroup(checkAll=True)
	if crystal.pointGroup:
		print('Crystal point group is %s' % crystal.pointGroup)
		print('%i symmetry operations found' % crystal.directOps.length)
	else:
		print('Crystal point group not found')
		print('%i symmetry operations matched' % crystal.directOps.length)
	print('-------------------------------------------------------------')
	'''

'''
#plt.ion()
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d', xlabel='x', ylabel='y', zlabel='z')
ax.plot(X([zeroVector,v0]), Y([zeroVector,v0]), Z([zeroVector,v0]), color='b')
ax.plot(X([zeroVector,v1]), Y([zeroVector,v1]), Z([zeroVector,v1]), color='b')
ax.plot(X([zeroVector,v2]), Y([zeroVector,v2]), Z([zeroVector,v2]), color='b')
ax.plot(X([zeroVector,axis1]), Y([zeroVector,axis1]), Z([zeroVector,axis1]), color='g')
ax.plot(X([zeroVector,axis2]), Y([zeroVector,axis2]), Z([zeroVector,axis2]), color='r')
ax.plot(X([v0,v2]), Y([v0,v2]), Z([v0,v2]), color='k')
plt.show()
raw_input('Press enter to continue.')
'''

	