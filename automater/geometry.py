import numpy.linalg as la
import numpy as np

I = np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]])
pi = np.pi
xHat = np.array([1.0, 0.0, 0.0])
yHat = np.array([0.0, 1.0, 0.0])
zHat = np.array([0.0, 0.0, 1.0])
zeroVector = np.array([0.0,0.0,0.0])


def Ry(theta):
	"""Generates a matrix which will rotate a vector about the y-axis by theta degrees"""
	return np.array([[np.cos(theta), 0, np.sin(theta)],
					 [0, 1, 0],
					 [-1*np.sin(theta), 0, np.cos(theta)]])

def Rz(theta):
	"""Generates a matrix which will rotate a vector about the z-axis by theta degrees"""
	return np.array([[np.cos(theta), -1*np.sin(theta), 0],
				[np.sin(theta), np.cos(theta), 0],
				[0, 0, 1]])

def Rx(theta):
	"""Generates a matrix which will rotate a vector about the x-axis by theta degrees"""
	return np.array([[1, 0, 0],
					[0, np.cos(theta), -1*np.sin(theta)],
					[0, np.sin(theta), np.cos(theta)]])

def xzProj(vector):
	"""Return the projection of vector onto the x-z plane"""
	return np.array([vector[0], 0, vector[2]])

def yzProj(vector):
	"""Return the projection of vector onto the y-z plane"""
	return np.array([0, vector[1], vector[2]])

def xyProj(vector):
	"""Return the projection of vector onto the x-y plane"""
	return np.array([vector[0], vector[1], 0])

def xzz(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the z axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[0] < 0:
			return -1*theta
		return theta
	else:
		return 0


def xzx(vector):
	"""Return the angle between the projecion of the given vector onto the x-z plane, and the x axis"""
	proj = xzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[2] > 0:
			return -1*theta
		return theta
	else:
		return proj

def yzz(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the z axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, zHat)
		if vector[1] > 0:
			return -1*theta
		return theta
	else:
		return 0

def yzy(vector):
	"""Return the angle between the projecion of the given vector onto the y-z plane, and the y axis"""
	proj = yzProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[2] < 0:
			return -1*theta
		return theta
	else:
		return 0

def xyy(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the y axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, yHat)
		if vector[0] > 0:
			return -1*theta
		return theta
	else:
		return 0

def xyx(vector):
	"""Return the angle between the projecion of the given vector onto the x-y plane, and the x axis"""
	proj = xyProj(vector)
	if np.absolute(la.norm(proj)) > 1e-9:
		theta = angle(proj, xHat)
		if vector[1] < 0:
			return -1*theta
		return theta
	else:
		return 0

def align2x(vectorSet, vector):
	"""Return a new set of vectors generated by rotating every member of vectorSet through the same rotation needed to align vector with x"""
	rx = Rx(-1*yzy(vector))
	newSet = [np.inner(rx, v) for v in vectorSet]
	vector = np.inner(rx, vector)
	return [np.inner(Rz(-1*xyx(vector)), v) for v in newSet]
					 
def angle(v1, v2):
	"""Return the angle between v1 and v2"""
	return np.arccos(np.dot(v1,v2)/(la.norm(v1)*la.norm(v2)))
					 
def distance(a, b):
	"""Calculate the distance between two vectors, ||a-b||"""
	return np.abs(la.norm(np.array(a) - np.array(b)))

def angles(number):
	"""generate a list of number equally spaced angles between 0 and 2pi"""
	return np.linspace(0, 2*pi, number, endpoint=False)

def genYrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the y-axis and which is orthogonal to y"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Ry(angle), vector)))
	return vectors

def genXrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the x-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rx(angle), vector)))
	return vectors

def genZrots(vector, number):
	"""Given a point in space, generate  list of number equally spaced points, one of which is the original, 
	along the circle whose radius is the line connecting the given point to the z-axis and which is orthogonal to z"""
	vector = np.array(vector)
	vectors = []
	for angle in angles(number):
		vectors.append(np.array(np.inner(Rz(angle), vector)))
	return vectors

def X(vectors):
	"""Take a list of vectors and return a list of the x-components of the vectors"""
	return np.array([x for x,y,z in vectors])

def Y(vectors):
	"""Take a list of vectors and return a list of the y-components of the vectors"""
	return np.array([y for x,y,z in vectors])

def Z(vectors):
	"""Take a list of vectors and return a list of the z-components of the vectors"""
	return np.array([z for x,y,z in vectors])

def seek(start, end, translations):
	"""Given two points in space, attempt to crawl from one point to the other using only the moves given by the vectors in translations.
	Return a list of points on the path taken"""
	i=0
	position = np.array(start)
	end = np.array(end)
	togo = distance(start, end)
	translations = [np.array(v) for v in translations]
	path = [position]
	moves = []
	for translation in translations:
		moves.append(translation)
		moves.append(-1*translation)
	while True:
		moved = False
		for move in moves:
			trialPosition = position + move
			if distance(trialPosition, end) < togo:
				position = trialPosition
				path.append(position)
				togo = distance(position, end)
				moved = True
		if not moved:
			break
		i+=1
		if i > 100:
			print('100 move limit reached.')
			return False
	return path


def genOp(axis, op):
	"""Given a symmetry element (axis), generate a set of matrices representing the given symmetry operation (zOp) about the element."""	
	theta = xzz(axis)
	ry = Ry(-1*theta)
	wyz = np.inner(ry,axis)
	phi = yzz(wyz)
	rx = Rx(-1*phi)
	toZ = np.matmul(rx,ry)
	fromZ = la.inv(toZ)
	return np.matmul(fromZ,np.matmul(op,toZ))

def genSymOps(opType, axis, order=False):
	"""Generate a dictionary of matrices representing rotations about the given axis angles of n*(360/order) where n = 1,...,order. Dictionary keys are n."""
	rots = {}
	if opType == 'rotation' or opType == 'rotoinversion':
		if not order:
			print('To generate a list of rotations with genSymOps(), you must provide a third argument indicating the order of the rotation')
			return False
		mOp = '-'+str(order) if opType == 'rotoinversion' else str(order)
		for n in range(1,order):
			rots['[%i/%s]' % (n,mOp)] = la.matrix_power(genOp(axis,M.array(mOp)),n)
	elif opType == 'reflection':
		rots['m'] = genOp(axis,M.array('m'))
	return rots

def cullOps(ops):
	"""Given a list of matrices, remove any duplicates and return the uniques"""
	tmpOps = []
	for op in ops:
		dupe = False
		for tmpOp in tmpOps:
			if np.allclose(op,tmpOp):
				dupe = True
		if not dupe:
			tmpOps.append(op)
	return tmpOps
	

def fillBox(translations, basis):
	"""For a given set of lattice translations and basis atoms, generate a 3x3x3 supercell"""
	atoms = []
	for vx in [-translations[0], zeroVector, translations[0]]:
		for vy in [-translations[1], zeroVector, translations[1]]:
			for vz in [-translations[2], zeroVector, translations[2]]:
				for b in basis:
					atoms.append([b[0],vx + vy + vz + b[1]])
	return atoms

def findMatch(box, atom):
	"""Search list of atoms (box) for an atom which is the same type and at the same position as the given atom"""
	shortestDistance = 5
	points = []
	for point in box:
		dist = distance(point[1],atom[1])
		if point[0] == atom[0] and distance(point[1],atom[1]) < 1e-5:
			return True
	return False	

def rotOnY(v, angle):
	"""Given a vector v and an angle, return a new vector which represents a rotation of v about the y-axis by the given angle"""
	return np.inner(Ry(angle), np.array(v))

def rotOnX(v, angle):
	"""Given a vector v and an angle, return a new vector which represents a rotation of v about the x-axis by the given angle"""
	return np.inner(Rx(angle), np.array(v))

def rotOnZ(v, angle):
	"""Given a vector v and an angle, return a new vector which represents a rotation of v about the z-axis by the given angle"""
	return np.inner(Rz(angle), np.array(v))

def onBox(edges, pt):
	"""Given a box defined by three edges, return a list of out of plane edges for which the pt is in the plane defined by the other two edges (inclusive)"""
	vs = []
	for i, edge in enumerate(edges):
		copys = [x for x in edges] 
		v = copys.pop(i)
		n = np.cross(copys[0], copys[1])
		n = (1/la.norm(n))*n
		if la.norm(np.dot(n,pt)) < 1e-5:
			vs.append(np.array(v))
	return vs
		

